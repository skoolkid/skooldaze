; Copyright 2001, 2008-2013, 2015, 2017, 2018 Richard Dymond

@defb=16643:24,0,60,64,126,60,124,0,60,8,60,60,60
@defb=16675:60,0,64,60,60,120,0,36,36,60,60,120,126,0,60,8,60,60,60
@defb=16707:60,0,64,60,60,120,0,36,36,60,60,120,126
@defb=16739:8,0,64,60,60,120,0,36,36,60,60,124,126,126,66,8
@defb=16771:126,0,126,60,124,0,0,0,24,0,254,60,0,60,60
@defb=16788:124,126,126,124,0,0,24,0,126,0,0,124,60,66,60,126,0,126,60
@defb=16809:66,126,66,254
@defb=16835:60,0,124,60,66,120,60,66,62,126,126,0,66,60,124
@defs=16851:5,60
@defb=16899:40,0,66,64,64,66,66,0,66,24,66,66,64
@defb=16931:66,0,64,66,66,68,0,36,36,66,66,68,64,0,66,24,66,66,66
@defb=16963:66,0,64,66,66,68,0,36,36,66,66,68,64
@defb=16995:24,0,64,66,66,68,0,36,36,64,66,66,64,64,98,62
@defb=17027:64,0,64,66,66,0,56,0,40,0,16,66,0,66,70
@defb=17044:66,64,64,66,0,0,40,0,2,0,0,66,66,66,64,64,0,64,70
@defb=17065:98,64,36,16,0,56
@defb=17091:64,0,66,66,98,68,66,102,8,4,64,0,66,64,66
@defs=17107:5,66
@defb=17155:8,0,64,64,124,66,66,0,2,40,2,60,124
@defb=17187:2,0,64,66,66,66,0,0,0,64,66,66,124,0,2,40,2,60,60
@defb=17219:12,0,64,66,66,66,0,0,0,64,66,66,124
@defb=17251:40,0,64,66,66,66,0,0,0,60,64,66,124,124,82,40
@defb=17283:124,0,124,66,66,0,4,62,8,0,16,66,0,12,74,16
@defb=17300:124,124,124,66,0,0,8,0,4,16,0,66,66,66,60,124,0,124,74,16
@defb=17321:82,124,24,16,0,4
@defb=17347:124,0,66,66,82,66,66,90,8,8,124,0,66,60,66
@defb=17363:12,2,2,2,60
@defb=17411:8,0,64,64,64,126,124,0,60,72,60,66,66
@defb=17443:60,0,64,66,126,66,0,0,0,64,66,66,64,0,60,72,60,66,66
@defb=17475:2,0,64,66,126,66,0,0,0,64,66,66,64
@defb=17507:72,0,64,66,126,66,0,0,0,2,64,124,64,64,74,62
@defb=17539:2,0,64,66,124,0,60,0,8,0,16,66,0,2,82
@defb=17556:66,64,64,124,0,0,8,0,8,0,0,124,126,66,2,64,0,2,82
@defb=17577:74,64,24,16,0,60
@defb=17603:66,0,124,126,74,66,66,66,8,16,64,0,66,2,124
@defb=17619:2,60,60,60,66
@defb=17667:8,0,66,64,64,66,68,0,64,126,64,66,66
@defb=17699:64,0,64,66,66,68,0,0,0,66,66,68,64,0,64,126,64,66,66
@defb=17731:66,0,64,66,66,68,0,0,0,66,66,68,64
@defb=17763:126,0,64,66,66,68,0,0,0,66,66,68,64,64,70,10
@defb=17795:66,0,64,66,68,0,68,62,8,0,16,66,0,66,98
@defb=17812:66,64,64,64,0,24,8,8,16,0,0,64,66,66,66,64,0,66,98
@defb=17833:70,64,36,16,0,68
@defb=17859:66,0,68,66,70,68,66,66,8,32,64,0,66,66,68
@defb=17875:66,64,64,64,66
@defb=17923:62,0,60,126,126,66,66,0,126,8,126,60,60
@defb=17955:126,0,126,60,66,120,0,0,0,60,60,120,126,0,126,8,126,60,60
@defb=17987:60,0,126,60,66,120,0,0,0,60,60,120,126
@defb=18019:8,0,126,60,66,120,0,0,0,60,60,66,126,126,66,62
@defb=18051:60,0,64,60,66,0,60,0,62,0,16,60,0,60,60,16
@defb=18068:124,126,126,64,0,24,62,8,16,16,0,64,66,60,60,126,0,60,60,16
@defb=18089:66,126,66,16,0,60
@defb=18115:60,0,66,66,66,120,60,66,62,126,126,0,60,60,66
@defb=18131:60,126,126,126,60
@defb=18290:8
@defb=18331:16
@defb=20704:255
@defb=20960:187
@defb=21216:183
@defb=21472:143
@defb=21728:183
@defb=21984:187
@defb=22240:189
@defb=22496:255
@defs=22528:768,56
@defb=23264:184
@start
@writer=:skooldaze.SkoolDazeAsmWriter
@replace=/#n\i/#N\1,,,1($)
@replace=/#b\i/#N\1,,,1(0x)/ (byte)
@replace=/#w\i/#N(\1,4)/ (word)
; Copyright 1984 Microsphere Computer Services Ltd (Skool Daze)
; Copyright 2001, 2008-2013, 2015, 2017, 2018 Richard Dymond (this disassembly)
@org=33024

; Save Skool Daze to tape
;
; #UDGTABLE
; { #SCR(saver.gif) | This is the program used to save the fast code block for
;                     Skool Daze. }
; TABLE#
; .
; Used by the routine at #R32484@main (which is located at #w32228 before
; #R24288@start is called).
; .
; The fast code block consists of two sections of data. The first section
; contains the 16573 bytes of data for addresses #w16384-#w32956. The second
; section contains 65535 bytes of data starting at address #w32971, moving
; forward in steps of 23 bytes, and ending at #w32925.
; .
; Note that the last three bytes in the first section (addresses
; #w32954-#w32956) are actually loaded into addresses #w32902, #w32925 and
; #w32948 by the #R32815@load(load routine). Note also that the last byte in
; the second section, for address #w32925, is not loaded by the
; #R32815@load(load routine).
c33024 LD IX,16384   ; {#w16384 to #w32956 will be saved first
 33028 LD DE,16572   ; }
 33031 LD A,255      ; A flag byte of #b255 (the first byte saved) indicates a
                     ; data block
 33033 LD HL,3224    ; This constant will give a leader tone of about 2 seconds
 33036 EX AF,AF'     ;
 33037 INC DE        ; {Adjust the length and start address to allow for the
 33038 DEC IX        ; flag byte}
 33040 DI            ; Disable interrupts
 33041 LD A,2        ; MIC on, border red
 33043 LD B,A        ;
; First create the 2-second leader tone.
@label=LEADER
*33044 DJNZ 33044    ;
 33046 OUT (254),A   ;
 33048 XOR 15        ;
 33050 LD B,164      ;
 33052 DEC L         ;
 33053 JR NZ,33044   ;
 33055 DEC B         ;
 33056 DEC H         ;
 33057 JP P,33044    ;
; Then create the sync pulse.
 33060 LD B,47       ;
@label=SYNC1
*33062 DJNZ 33062    ;
 33064 OUT (254),A   ;
 33066 LD A,13       ;
 33068 LD B,55       ;
@label=SYNC2
*33070 DJNZ 33070    ;
 33072 OUT (254),A   ;
; It's time to save the first byte, which will be the flag byte (#b255).
 33074 LD BC,6670    ; #REGb=#b26 (timing constant), #REGc=#b14 (MIC off,
                     ; border yellow)
 33077 EX AF,AF'     ; #REGa=#b255
 33078 LD L,A        ; #REGl=#b255
 33079 JP 33091      ; Jump forward to save the flag byte
; This is the main byte-saving loop.
@label=B1_LOOP
*33082 LD A,D        ; {In the analagous ROM routine, the second instruction
 33083 LD A,D        ; here is '#S/OR E/', to check whether it's time to save
                     ; the last byte (the parity byte)}
 33084 JR Z,33098    ; This jump (to save the parity byte) is never made
 33086 LD L,(IX+0)   ; Fetch the next byte to be saved
@label=B1_LOOP_P
*33089 LD A,H        ; #REGa=current parity byte
 33090 XOR L         ; Update this for the next byte to be saved
@label=B1_START
*33091 LD H,A        ; #REGh=new parity byte
 33092 LD A,1        ; #REGa=#b1 (MIC on, border blue)
 33094 SCF           ; Set the carry flag (which will act as the marker bit)
 33095 JP 33121      ; Jump forward to save the byte
; This section of code, if it were used, would save the parity byte.
@label=B1_PARITY
*33098 LD L,H        ; Pick up the parity byte in #REGl
 33099 JR 33089      ; Save it
; This is the bit-saving loop for the first section of data (#w16384-#w32956).
@label=B1_BIT2
*33101 LD A,C        ; #REGa=#b14 (MIC off, border yellow) for the second pass
 33102 BIT 7,B       ; Set the zero flag to indicate that this is the second
                     ; pass through the loop
@label=B1_BIT1
*33104 DJNZ 33104    ;
 33106 JR NC,33112   ; Jump if we are saving a '0'
 33108 LD B,32       ;
@label=B1_SET
*33110 DJNZ 33110    ;
@label=B1_OUT
*33112 OUT (254),A   ;
 33114 LD B,29       ; Set the timing constant for the second pass
 33116 JR NZ,33101   ; Jump back for the second pass if we've just done the
                     ; first
 33118 DEC B         ;
 33119 XOR A         ; Clear the carry flag
 33120 INC A         ; #REGa=#b1 (MIC on, border blue)
@label=B1_8BITS
*33121 RL L          ; Move the bit to be saved into the carry flag, and the
                     ; marker bit leftwards
 33123 JP NZ,33104   ; Jump unless we've saved all 8 bits of the byte
; A byte from the first section (#w16384-#w32956) has just been saved. Are
; there any more left?
 33126 DEC DE        ; Decrease the length counter
 33127 INC IX        ; Move to the next byte to be saved
 33129 LD B,16       ; Set the timing constant for the first bit of the next
                     ; byte
 33131 LD A,127      ; {Return if the BREAK key is being pressed
 33133 IN A,(254)    ;
 33135 RRA           ;
 33136 RET NC        ; }
 33137 LD A,D        ; {Have we saved #w16384 to #w32956 yet?
 33138 INC A         ; }
 33139 JP NZ,33082   ; Jump back if not
; Now a further 65535 bytes are saved: starting at #w32971, moving forward in
; steps of 23 bytes, and ending at #w32925.
@label=B2_LOOP
*33142 LD A,D        ; {#REGix=#w32957 and #REGde=#w65535 the first time we get
 33143 OR E          ; here}
 33144 JR Z,33158    ; Jump if we have now saved #w32971 onwards
 33146 LD L,(IX+14)  ; #REGix+#b14=#w32971 the first time we get here
 33149 LD A,H        ; #REGa=current parity byte
 33150 XOR L         ; Update this for the next byte to be saved
 33151 LD H,A        ; #REGh=new parity byte
 33152 LD A,1        ; #REGa=#b1 (MIC on, border blue)
 33154 SCF           ; Set the carry flag (which will act as the marker bit)
 33155 JP 33181      ; Jump forward to save the byte
; This is where we come when all 82108 bytes have been saved.
@label=DONE
*33158 LD L,0        ;
 33160 RET           ;
; This is the bit-saving loop for the second section of data.
@label=B2_BIT2
*33161 LD A,C        ; #REGa=#b14 (MIC off, border yellow) for the second pass
 33162 BIT 7,B       ; Set the zero flag to indicate that this is the second
                     ; pass through the loop
@label=B2_BIT1
*33164 DJNZ 33164    ;
 33166 JR NC,33172   ; Jump if we are saving a '0'
 33168 LD B,32       ;
@label=B2_SET
*33170 DJNZ 33170    ;
@label=B2_OUT
*33172 OUT (254),A   ;
 33174 LD B,29       ; Set the timing constant for the second pass
 33176 JR NZ,33161   ; Jump back for the second pass if we've just done the
                     ; first
 33178 DEC B         ;
 33179 XOR A         ; Clear the carry flag
 33180 INC A         ; #REGa=#b1 (MIC on, border blue)
@label=B2_8BITS
*33181 RL L          ; Move the bit to be saved into the carry flag, and the
                     ; marker bit leftwards
 33183 JP NZ,33164   ; Jump unless we've saved all 8 bits of the byte
; A byte from the second section has just been saved. Are there any more left?
 33186 DEC DE        ; Decrease the length counter
 33187 EXX           ; {Move forward 23 bytes to the next byte to be saved
 33188 ADD IX,BC     ;
 33190 EXX           ; }
 33191 LD B,16       ; Set the timing constant for the first bit of the next
                     ; byte
 33193 LD A,127      ; {These instructions check the BREAK key but do not act
 33195 IN A,(254)    ; on the result
 33197 RRA           ; }
 33198 JP 33142      ; Save the next byte
@end
; The last 5 bytes of the first section saved make important changes to the
; #R32815@load(load routine) when the game is being loaded:
v32952 JR NZ,32893   ; This will replace the '#S/JR NZ/,#n32907' at #w32952,
                     ; and kick off the loading of 65537 bytes from #w32902
                     ; onwards (in steps of 23, all the way round to #w32902
                     ; again)
v32954 DEFB 32       ; This byte will replace the #b49 at #w32902, changing the
                     ; instruction there from '#S/LD SP/,#n23833' to
                     ; '#S/JR NZ/,#n32929'
v32955 DEFB 221      ; This byte will be loaded into #w32925 (which already
                     ; contains #b221)
v32956 DEFB 173      ; This byte will be loaded into #w32948 (which already
                     ; contains #b173)
